package host

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/shinzonetwork/shinzo-app-sdk/pkg/defra"
	"github.com/shinzonetwork/shinzo-host-client/pkg/shinzohub"
	"github.com/shinzonetwork/shinzo-host-client/pkg/view"
	"github.com/shinzonetwork/shinzo-view-creator/core/models"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestViewLifecycleIntegration tests the complete view lifecycle:
// 1. Start host
// 2. Query event routes
// 3. Register a view through Shinzo Hub event
// 4. Verify HTTP endpoint creation
// 5. Process documents and verify endpoint updates
func TestViewLifecycleIntegration(t *testing.T) {
	// STEP 1: Start the host
	host, err := StartHostingWithTestConfig(t)
	require.NoError(t, err, "Failed to start host")
	defer func() {
		if host != nil {
			host.Close(context.Background())
		}
	}()

	// Wait for host to fully initialize
	time.Sleep(2 * time.Second)

	// STEP 2: Test querying the event route endpoints
	t.Run("QueryEventRoutes", func(t *testing.T) {
		testQueryEventRoutes(t, host)
	})

	// STEP 3: Create and register a test view through Shinzo Hub event
	t.Run("ViewRegistrationLifecycle", func(t *testing.T) {
		testViewRegistrationLifecycle(t, host)
	})

	// STEP 4: Test document processing and endpoint updates
	t.Run("DocumentProcessingLifecycle", func(t *testing.T) {
		testDocumentProcessingLifecycle(t, host)
	})

	// STEP 5: Start HTTP server and open view route in browser
	t.Run("LiveViewDemo", func(t *testing.T) {
		testLiveViewDemo(t, host)
	})
}

// testQueryEventRoutes tests the /api/v0/views endpoint
func testQueryEventRoutes(t *testing.T, host *Host) {
	// Create a test HTTP server with the host's view endpoints
	mux := http.NewServeMux()
	host.RegisterViewEndpoints(mux)

	server := httptest.NewServer(mux)
	defer server.Close()

	// Test the main views listing endpoint
	resp, err := http.Get(server.URL + "/api/v0/views")
	require.NoError(t, err, "Failed to query views endpoint")
	defer resp.Body.Close()

	assert.Equal(t, http.StatusOK, resp.StatusCode, "Views endpoint should return 200")
	assert.Equal(t, "application/json", resp.Header.Get("Content-Type"), "Should return JSON")

	var viewsResponse map[string]interface{}
	err = json.NewDecoder(resp.Body).Decode(&viewsResponse)
	require.NoError(t, err, "Failed to decode JSON response")

	// Initially should have 0 views
	assert.Equal(t, float64(0), viewsResponse["available_views"], "Should start with 0 views")
	assert.NotNil(t, viewsResponse["endpoints"], "Should have endpoints array")

	t.Logf("‚úÖ Event routes query successful: %+v", viewsResponse)
}

// testViewRegistrationLifecycle tests the complete view registration process
func testViewRegistrationLifecycle(t *testing.T, host *Host) {
	ctx := context.Background()

	// LIFECYCLE STEP 1: Create Transaction document first to get actual _docID
	// Use unique hash to avoid conflicts with previous test runs
	uniqueHash := fmt.Sprintf("0xfiltered%d", time.Now().UnixNano())
	testDoc := Document{
		Type:        "Transaction",
		BlockNumber: 12345,
		Data: map[string]interface{}{
			"hash":        uniqueHash,
			"blockNumber": 12345,
			"from":        "0xabc123",
			"to":          "0xdef456",
			"value":       "1000000000000000000",
		},
	}

	createQuery := fmt.Sprintf(`
		mutation {
			create_Transaction(input: {
				hash: "%s"
				blockNumber: %d
				from: "%s"
				to: "%s"
				value: "%s"
			}) {
				_docID
			}
		}
	`, testDoc.Data["hash"], testDoc.BlockNumber, testDoc.Data["from"], testDoc.Data["to"], testDoc.Data["value"])

	result, err := defra.QuerySingle[map[string]interface{}](ctx, host.DefraNode, createQuery)
	require.NoError(t, err, "Should be able to create Transaction document in DefraDB")
	t.Logf("Mutation result: %+v", result)

	// Check if result is nil or empty
	if result == nil {
		t.Fatal("Mutation result is nil")
	}

	// Extract the actual _docID generated by DefraDB (returned directly in result)
	docIDRaw, exists := result["_docID"]
	if !exists {
		t.Fatalf("_docID field not found in result: %+v", result)
	}

	actualDocID, ok := docIDRaw.(string)
	if !ok {
		t.Fatalf("_docID is not a string: %T = %+v", docIDRaw, docIDRaw)
	}

	t.Logf("Created Transaction with ID: %s", actualDocID)

	// Store the document ID for use in document processing test
	registeredDocumentID = actualDocID

	// LIFECYCLE STEP 2: Create test view with WASM lens that filters for this specific document
	testView := createTestViewWithDocID(actualDocID)

	// LIFECYCLE STEP 3: Create ViewRegisteredEvent (simulating Shinzo Hub event)
	registeredEvent := shinzohub.ViewRegisteredEvent{
		Key:     "test-view-key-123",
		Creator: "test-creator-address",
		View:    testView,
	}

	// LIFECYCLE STEP 4: Process the registration event
	err = host.viewRegistrationHandler.ProcessRegisteredEvent(ctx, registeredEvent)
	require.NoError(t, err, "View registration should succeed")

	// Wait for processing
	time.Sleep(1 * time.Second)

	// LIFECYCLE STEP 3: Verify view was registered with ViewManager
	viewStats, err := host.GetViewStats(testView.Name)
	require.NoError(t, err, "Should be able to get view stats")
	assert.Equal(t, testView.Name, viewStats.Name, "View name should match")
	assert.True(t, viewStats.IsActive, "View should be active")

	// LIFECYCLE STEP 4: Verify HTTP endpoint was created
	endpoints := host.GetViewEndpoints()
	assert.Contains(t, endpoints, testView.Name, "Should have endpoint for test view")

	endpoint := endpoints[testView.Name]
	expectedPath := fmt.Sprintf("/api/v0/views/%s", strings.ToLower(strings.ReplaceAll(testView.Name, " ", "-")))
	assert.Equal(t, expectedPath, endpoint.Path, "Endpoint path should be correct")

	// LIFECYCLE STEP 5: Test the HTTP endpoint
	mux := http.NewServeMux()
	host.RegisterViewEndpoints(mux)
	server := httptest.NewServer(mux)
	defer server.Close()

	// Query the specific view endpoint
	resp, err := http.Get(server.URL + endpoint.Path)
	require.NoError(t, err, "Failed to query view endpoint")
	defer resp.Body.Close()

	assert.Equal(t, http.StatusOK, resp.StatusCode, "View endpoint should return 200")

	var viewData map[string]interface{}
	err = json.NewDecoder(resp.Body).Decode(&viewData)
	require.NoError(t, err, "Failed to decode view data")

	assert.Equal(t, testView.Name, viewData["view_name"], "View name should match")
	assert.NotNil(t, viewData["data"], "Should have data field")
	assert.NotNil(t, viewData["data_count"], "Should have data_count field")

	t.Logf("‚úÖ View registration lifecycle complete for %s at %s", testView.Name, endpoint.Path)
}

// Store the document ID from view registration for use in document processing
var registeredDocumentID string

// testDocumentProcessingLifecycle tests document processing through views
func testDocumentProcessingLifecycle(t *testing.T, host *Host) {
	ctx := context.Background()

	// Get existing view endpoints to test against
	endpoints := host.GetViewEndpoints()
	require.NotEmpty(t, endpoints, "Should have at least one view registered")

	// Get the first view for testing
	var testViewName string
	var testEndpoint *ViewEndpoint
	for name, endpoint := range endpoints {
		testViewName = name
		testEndpoint = endpoint
		break
	}

	// LIFECYCLE STEP 0: Use the same document ID that the view was registered with
	// This ensures the WASM lens filter will match the document
	if registeredDocumentID == "" {
		t.Skip("No registered document ID available - skipping document processing test")
		return
	}

	t.Logf("Processing document with registered ID: %s", registeredDocumentID)

	// Create a test document that represents the registered document
	testDoc := Document{
		ID:          registeredDocumentID,
		Type:        "Transaction",
		BlockNumber: 12345,
		Data: map[string]interface{}{
			"_docID":      registeredDocumentID,
			"hash":        "0xregisteredtxhash",
			"blockNumber": 12345,
			"from":        "0xabc123",
			"to":          "0xdef456",
			"value":       "1000000000000000000",
		},
	}

	// LIFECYCLE STEP 1: Process the document through ViewManager
	// This should trigger the WASM lens transformation for the existing document
	host.viewManager.ProcessDocument(ctx, testDoc)

	// Wait for processing attempt
	time.Sleep(2 * time.Second)

	// LIFECYCLE STEP 2: Verify endpoint is accessible (even if no data was processed)
	mux := http.NewServeMux()
	host.RegisterViewEndpoints(mux)
	server := httptest.NewServer(mux)
	defer server.Close()

	// Query the view endpoint
	resp, err := http.Get(server.URL + testEndpoint.Path)
	require.NoError(t, err, "Failed to query view endpoint")
	defer resp.Body.Close()

	var viewData map[string]interface{}
	err = json.NewDecoder(resp.Body).Decode(&viewData)
	require.NoError(t, err, "Failed to decode view data")

	// LIFECYCLE STEP 3: Verify view stats (processing may have failed due to no lenses)
	viewStats, err := host.GetViewStats(testViewName)
	require.NoError(t, err, "Should be able to get view stats")

	// For views without lenses, processing will fail, so we just verify the endpoint works
	t.Logf("‚úÖ Document processing lifecycle complete: endpoint accessible, view stats available")
	t.Logf("üìä View stats: processed=%d, active=%v, last_updated=%s",
		viewStats.ProcessedDocs, viewStats.IsActive, viewData["last_updated"])
}

// createTestView creates a test view definition for lifecycle testing
func createTestView() view.View {
	// DefraDB AddView expects just the collection part, not a full GraphQL query
	// Use proper DefraDB filter syntax - _ge instead of _gte
	query := `Transaction {
		_docID
		hash
		blockNumber
		from
		to
		value
	}`

	sdl := `type TestTransactionView {
		hash: String
		blockNumber: Int
		from: String
		to: String
		value: String
	}`

	// Read the real WASM file and encode it as base64
	wasmBytes, err := os.ReadFile("/tmp/filter_transaction.wasm")
	if err != nil {
		// If WASM file not found, create a view without lenses for error testing
		return view.View{
			Name:  "TestTransactionView",
			Query: &query,
			Sdl:   &sdl,
		}
	}

	wasmBase64 := base64.StdEncoding.EncodeToString(wasmBytes)

	// Create view with proper lens transformation
	// Based on the Rust code, this lens filters documents where src field matches value
	viewDef := view.View{
		Name:  "TestTransactionView",
		Query: &query,
		Sdl:   &sdl,
	}

	// Set the Transform field with the real WASM lens
	// This requires using the actual structure from views.View
	return createViewWithTransform(viewDef, wasmBase64)
}

// createTestViewWithDocID creates a test view with WASM lens that filters for a specific document ID
func createTestViewWithDocID(docID string) view.View {
	query := `Transaction {
		_docID
		hash
		blockNumber
		from
		to
		value
	}`

	sdl := `type TestTransactionView {
		hash: String
		blockNumber: Int
		from: String
		to: String
		value: String
	}`

	// Read the real WASM file and encode it as base64
	wasmBytes, err := os.ReadFile("/tmp/filter_transaction.wasm")
	if err != nil {
		// If WASM file not found, create a view without lenses for error testing
		return view.View{
			Name:  "TestTransactionView",
			Query: &query,
			Sdl:   &sdl,
		}
	}

	wasmBase64 := base64.StdEncoding.EncodeToString(wasmBytes)

	viewDef := view.View{
		Name:  "TestTransactionView",
		Query: &query,
		Sdl:   &sdl,
	}

	return createViewWithTransformForDocID(viewDef, wasmBase64, docID)
}

// createViewWithTransformForDocID creates a view with WASM lens that filters for a specific document ID
func createViewWithTransformForDocID(viewDef view.View, wasmBase64 string, docID string) view.View {
	// Create parameters that match the Rust Parameters struct
	// Use the actual document ID from DefraDB
	lensParams := map[string]any{
		"src":   "_docID",
		"value": docID, // Use the actual document ID from DefraDB
	}

	// Create the lens with real WASM data
	lens := models.Lens{
		Label:     "filter_transaction",
		Path:      wasmBase64,
		Arguments: lensParams,
	}

	// Set the Transform field with the lens
	viewDef.Transform = models.Transform{
		Lenses: []models.Lens{lens},
	}

	return viewDef
}

// createViewWithTransform creates a view with WASM lens transformation
func createViewWithTransform(viewDef view.View, wasmBase64 string) view.View {
	// Based on the Rust code, the WASM expects a Parameters struct with src and value fields
	// The Rust code shows: pub struct Parameters { pub src: String, pub value: serde_json::Value }
	// The Rust WASM only passes through documents where input[src] == params.value exactly

	// Create parameters that match the Rust Parameters struct
	// Use _docID since we know this field exists in the GraphQL query result
	lensParams := map[string]any{
		"src":   "_docID",
		"value": "test-tx-filtered", // Must exactly match the test document's ID to pass through
	}

	// Create the lens with real WASM data
	lens := models.Lens{
		Label:     "filter_transaction",
		Path:      wasmBase64, // Real WASM data as base64
		Arguments: lensParams,
	}

	// Set the Transform field with the lens
	viewDef.Transform = models.Transform{
		Lenses: []models.Lens{lens},
	}

	return viewDef
}

// TestViewEndpointManager tests the ViewEndpointManager functionality in isolation
func TestViewEndpointManager(t *testing.T) {
	host, err := StartHostingWithTestConfig(t)
	require.NoError(t, err)
	defer host.Close(context.Background())

	endpointManager := host.viewManager.GetEndpointManager()
	require.NotNil(t, endpointManager, "EndpointManager should be initialized")

	// Test creating an endpoint
	endpoint, err := endpointManager.CreateEndpointForView("TestView")
	require.NoError(t, err, "Should create endpoint successfully")
	assert.Equal(t, "TestView", endpoint.ViewName)
	assert.Equal(t, "/api/v0/views/testview", endpoint.Path)

	// Test updating endpoint data
	testData := []map[string]interface{}{
		{"id": "1", "name": "test1"},
		{"id": "2", "name": "test2"},
	}

	err = endpointManager.UpdateViewData("TestView", testData)
	require.NoError(t, err, "Should update data successfully")

	// Test HTTP handler
	req := httptest.NewRequest("GET", endpoint.Path, nil)
	w := httptest.NewRecorder()
	endpoint.Handler(w, req)

	assert.Equal(t, http.StatusOK, w.Code)

	var response map[string]interface{}
	err = json.NewDecoder(w.Body).Decode(&response)
	require.NoError(t, err)

	assert.Equal(t, "TestView", response["view_name"])
	assert.Equal(t, float64(2), response["data_count"])

	t.Logf("‚úÖ ViewEndpointManager test complete")
}

// testLiveViewDemo starts an HTTP server and opens the view route in browser
func testLiveViewDemo(t *testing.T, host *Host) {
	// Create HTTP server with view endpoints
	mux := http.NewServeMux()
	host.RegisterViewEndpoints(mux)

	// Use httptest.NewServer for reliable address handling
	testServer := httptest.NewServer(mux)
	defer testServer.Close()

	// Get view endpoints
	endpoints := host.GetViewEndpoints()
	require.NotEmpty(t, endpoints, "Should have at least one view endpoint")

	// Get the first view endpoint
	var viewName string
	var viewPath string
	for name, endpoint := range endpoints {
		viewName = name
		viewPath = endpoint.Path
		break
	}

	// Construct full URL
	baseURL := testServer.URL
	viewURL := baseURL + viewPath
	listURL := baseURL + "/api/v0/views"

	t.Logf("üåê HTTP Server running at: %s", baseURL)
	t.Logf("üìã Views list endpoint: %s", listURL)
	t.Logf("üéØ View '%s' endpoint: %s", viewName, viewURL)

	// Test the endpoints are working
	resp, err := http.Get(listURL)
	require.NoError(t, err)
	defer resp.Body.Close()
	assert.Equal(t, http.StatusOK, resp.StatusCode)

	resp2, err := http.Get(viewURL)
	require.NoError(t, err)
	defer resp2.Body.Close()
	assert.Equal(t, http.StatusOK, resp2.StatusCode)

	time.Sleep(100 * time.Second)

	t.Logf("‚úÖ All endpoints are responding correctly")
	t.Logf("üöÄ View lifecycle complete! Access your view at: %s", viewURL)

	// Open browser preview for the view endpoint
	t.Logf("üåê Opening browser preview for live view demo...")

	// Keep server running for demonstration
	t.Logf("‚è≥ Keeping server running for 10 seconds for live demo...")

	t.Logf("üèÅ Live demo completed - server will close automatically")
}
